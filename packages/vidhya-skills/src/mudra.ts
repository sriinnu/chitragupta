/**
 * @module mudra
 * @description Mudra (मुद्रा) — Integrity Hashing & Cryptographic Signing for Skills.
 *
 * "Mudra" means seal or stamp in Sanskrit — the royal guarantee that a document
 * is authentic and untampered. This module provides:
 *
 * - **SHA-256 per-file integrity**: Hash every file in a skill directory.
 * - **Merkle-style root hash**: Deterministic root from sorted file hashes.
 * - **Ed25519 signing**: Compact, fast cryptographic provenance.
 * - **Verification**: Check integrity and signature without external PKI.
 *
 * Files: INTEGRITY.json and SIGNATURE.json in the skill directory.
 *
 * @packageDocumentation
 */

import { createHash } from "node:crypto";
import { readFile, readdir, stat, writeFile } from "node:fs/promises";
import { join, relative } from "node:path";
import type {
	IntegrityVerification,
	SkillIntegrity,
	SkillSignature,
} from "./types-v2.js";

// ─── Constants ──────────────────────────────────────────────────────────────

/** Files generated by mudra — excluded from integrity computation. */
const EXCLUDED_FILES = new Set(["INTEGRITY.json", "SIGNATURE.json"]);

/** Integrity manifest filename. */
export const INTEGRITY_FILE = "INTEGRITY.json";

/** Signature manifest filename. */
export const SIGNATURE_FILE = "SIGNATURE.json";

// ─── File Walking ───────────────────────────────────────────────────────────

/**
 * Recursively list all files under a directory, returning relative paths.
 * Excludes INTEGRITY.json and SIGNATURE.json.
 */
async function walkFiles(dir: string, base?: string): Promise<string[]> {
	const root = base ?? dir;
	const entries = await readdir(dir, { withFileTypes: true });
	const files: string[] = [];

	for (const entry of entries) {
		const fullPath = join(dir, entry.name);
		if (entry.isDirectory()) {
			files.push(...(await walkFiles(fullPath, root)));
		} else if (entry.isFile() && !EXCLUDED_FILES.has(entry.name)) {
			files.push(relative(root, fullPath));
		}
	}

	return files.sort();
}

// ─── Integrity ──────────────────────────────────────────────────────────────

/**
 * Compute SHA-256 hash for a single file.
 */
async function hashFile(filePath: string): Promise<string> {
	const content = await readFile(filePath);
	return createHash("sha256").update(content).digest("hex");
}

/**
 * Compute deterministic root hash from file hashes.
 * Concatenates sorted "path:hash" pairs, then SHA-256 the whole thing.
 */
function computeRootHash(files: Record<string, string>): string {
	const sorted = Object.entries(files).sort(([a], [b]) => a.localeCompare(b));
	const payload = sorted.map(([path, hash]) => `${path}:${hash}`).join("\n");
	return createHash("sha256").update(payload).digest("hex");
}

/**
 * Compute integrity manifest for a skill directory.
 *
 * Walks all files (excluding INTEGRITY.json and SIGNATURE.json),
 * computes SHA-256 per file, and produces a deterministic root hash.
 *
 * @param skillDir - Absolute path to the skill directory.
 * @returns The computed integrity manifest.
 */
export async function computeIntegrity(skillDir: string): Promise<SkillIntegrity> {
	const filePaths = await walkFiles(skillDir);
	const files: Record<string, string> = {};

	for (const relPath of filePaths) {
		files[relPath] = await hashFile(join(skillDir, relPath));
	}

	return {
		files,
		rootHash: computeRootHash(files),
		algorithm: "sha256",
		timestamp: new Date().toISOString(),
	};
}

/**
 * Verify a skill directory against an integrity manifest.
 *
 * Checks:
 * - Modified: files whose hash doesn't match.
 * - Missing: files in the manifest but not on disk.
 * - Added: files on disk but not in the manifest.
 *
 * @param skillDir - Absolute path to the skill directory.
 * @param integrity - The integrity manifest to verify against.
 * @returns Verification result with lists of modified, missing, and added files.
 */
export async function verifyIntegrity(
	skillDir: string,
	integrity: SkillIntegrity,
): Promise<IntegrityVerification> {
	const modified: string[] = [];
	const missing: string[] = [];
	const added: string[] = [];

	// Check all files in the manifest
	for (const [relPath, expectedHash] of Object.entries(integrity.files)) {
		const fullPath = join(skillDir, relPath);
		try {
			const s = await stat(fullPath);
			if (!s.isFile()) {
				missing.push(relPath);
				continue;
			}
			const actualHash = await hashFile(fullPath);
			if (actualHash !== expectedHash) {
				modified.push(relPath);
			}
		} catch {
			missing.push(relPath);
		}
	}

	// Check for new files not in the manifest
	const currentFiles = await walkFiles(skillDir);
	for (const relPath of currentFiles) {
		if (!(relPath in integrity.files)) {
			added.push(relPath);
		}
	}

	return {
		valid: modified.length === 0 && missing.length === 0 && added.length === 0,
		modified,
		missing,
		added,
	};
}

/**
 * Write an integrity manifest to INTEGRITY.json in the skill directory.
 *
 * @param skillDir - Absolute path to the skill directory.
 * @param integrity - The integrity manifest to write.
 */
export async function writeIntegrity(skillDir: string, integrity: SkillIntegrity): Promise<void> {
	await writeFile(join(skillDir, INTEGRITY_FILE), JSON.stringify(integrity, null, 2) + "\n", "utf-8");
}

/**
 * Read an integrity manifest from INTEGRITY.json in the skill directory.
 *
 * @param skillDir - Absolute path to the skill directory.
 * @returns The parsed integrity manifest, or null if not found.
 */
export async function readIntegrity(skillDir: string): Promise<SkillIntegrity | null> {
	try {
		const content = await readFile(join(skillDir, INTEGRITY_FILE), "utf-8");
		return JSON.parse(content) as SkillIntegrity;
	} catch {
		return null;
	}
}

// ─── Ed25519 Signing ────────────────────────────────────────────────────────

/**
 * Generate an Ed25519 key pair for signing skills.
 *
 * @returns Object with base64-encoded public and private keys.
 */
export async function generateKeyPair(): Promise<{
	publicKey: string;
	privateKey: string;
}> {
	const { generateKeyPairSync } = await import("node:crypto");
	const { publicKey, privateKey } = generateKeyPairSync("ed25519", {
		publicKeyEncoding: { type: "spki", format: "der" },
		privateKeyEncoding: { type: "pkcs8", format: "der" },
	});
	return {
		publicKey: Buffer.from(publicKey).toString("base64"),
		privateKey: Buffer.from(privateKey).toString("base64"),
	};
}

/**
 * Sign an integrity root hash with an Ed25519 private key.
 *
 * @param rootHash - The hex root hash from SkillIntegrity.
 * @param privateKeyBase64 - Base64-encoded Ed25519 private key (PKCS8 DER).
 * @returns The skill signature manifest.
 */
export async function signIntegrity(
	rootHash: string,
	privateKeyBase64: string,
): Promise<SkillSignature> {
	const { sign, createPrivateKey, createPublicKey } = await import("node:crypto");
	const privateKeyDer = Buffer.from(privateKeyBase64, "base64");
	const privKey = createPrivateKey({ key: privateKeyDer, format: "der", type: "pkcs8" });
	const pubKey = createPublicKey(privKey);

	const signature = sign(null, Buffer.from(rootHash, "hex"), privKey);
	const publicKeyDer = pubKey.export({ type: "spki", format: "der" });

	return {
		rootHash,
		signature: signature.toString("base64"),
		publicKey: Buffer.from(publicKeyDer).toString("base64"),
		algorithm: "ed25519",
		timestamp: new Date().toISOString(),
	};
}

/**
 * Verify an Ed25519 signature against a root hash.
 *
 * @param sig - The skill signature manifest.
 * @returns True if the signature is valid.
 */
export async function verifySignature(sig: SkillSignature): Promise<boolean> {
	try {
		const { verify, createPublicKey } = await import("node:crypto");
		const publicKeyDer = Buffer.from(sig.publicKey, "base64");
		const pubKey = createPublicKey({ key: publicKeyDer, format: "der", type: "spki" });
		const signatureBuffer = Buffer.from(sig.signature, "base64");

		return verify(null, Buffer.from(sig.rootHash, "hex"), pubKey, signatureBuffer);
	} catch {
		return false;
	}
}

/**
 * Write a signature manifest to SIGNATURE.json in the skill directory.
 *
 * @param skillDir - Absolute path to the skill directory.
 * @param sig - The signature manifest to write.
 */
export async function writeSignature(skillDir: string, sig: SkillSignature): Promise<void> {
	await writeFile(join(skillDir, SIGNATURE_FILE), JSON.stringify(sig, null, 2) + "\n", "utf-8");
}

/**
 * Read a signature manifest from SIGNATURE.json in the skill directory.
 *
 * @param skillDir - Absolute path to the skill directory.
 * @returns The parsed signature manifest, or null if not found.
 */
export async function readSignature(skillDir: string): Promise<SkillSignature | null> {
	try {
		const content = await readFile(join(skillDir, SIGNATURE_FILE), "utf-8");
		return JSON.parse(content) as SkillSignature;
	} catch {
		return null;
	}
}

// ─── Convenience: Seal a Skill ──────────────────────────────────────────────

/**
 * Compute integrity and optionally sign a skill directory.
 * Writes INTEGRITY.json (always) and SIGNATURE.json (if private key provided).
 *
 * @param skillDir - Absolute path to the skill directory.
 * @param privateKeyBase64 - Optional Ed25519 private key for signing.
 * @returns Object with the integrity and optional signature.
 */
export async function sealSkill(
	skillDir: string,
	privateKeyBase64?: string,
): Promise<{ integrity: SkillIntegrity; signature?: SkillSignature }> {
	const integrity = await computeIntegrity(skillDir);
	await writeIntegrity(skillDir, integrity);

	let signature: SkillSignature | undefined;
	if (privateKeyBase64) {
		signature = await signIntegrity(integrity.rootHash, privateKeyBase64);
		await writeSignature(skillDir, signature);
	}

	return { integrity, signature };
}

/**
 * Verify a skill directory's integrity and optional signature.
 *
 * @param skillDir - Absolute path to the skill directory.
 * @returns Object with integrity verification and optional signature validity.
 */
export async function verifySeal(
	skillDir: string,
): Promise<{ integrity: IntegrityVerification | null; signatureValid: boolean | null }> {
	const integrityManifest = await readIntegrity(skillDir);
	if (!integrityManifest) {
		return { integrity: null, signatureValid: null };
	}

	const integrity = await verifyIntegrity(skillDir, integrityManifest);

	const sig = await readSignature(skillDir);
	const signatureValid = sig ? await verifySignature(sig) : null;

	return { integrity, signatureValid };
}
