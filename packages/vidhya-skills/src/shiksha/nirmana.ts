/**
 * Nirmana (निर्माण — Construction) — Skill Builder.
 *
 * Takes a TaskAnalysis + SourceResult and produces a complete GeneratedSkill:
 * - SkillManifest for the registry
 * - skill.md content for persistence
 * - Typed implementation (shell, tool-chain, typescript, llm-chain)
 *
 * @packageDocumentation
 */

import type { SkillManifest, SkillCapability } from "../types.js";
import { computeTraitVector } from "../fingerprint.js";
import { writeSkillMarkdown } from "../writer.js";
import type {
	TaskAnalysis,
	SourceResult,
	GeneratedSkill,
	SourceImplementation,
} from "./types.js";

// ─── Skill Name Generation ─────────────────────────────────────────────────

/**
 * Generate a kebab-case skill name from the task analysis.
 *
 * Examples:
 * - "check devices on network" → "check-devices-network"
 * - "disk space left" → "measure-disk-space"
 */
function generateSkillName(analysis: TaskAnalysis): string {
	const intent = analysis.intents[0];
	if (!intent) {
		// Fallback: sanitize query
		return sanitizeName(analysis.query);
	}

	const parts = [intent.verb, intent.object];
	if (intent.modifier) {
		// Extract 1-2 key words from modifier
		const modWords = intent.modifier
			.split(/\s+/)
			.filter((w) => w.length > 2 && !/^(my|the|this|that|a|an)$/i.test(w))
			.slice(0, 2);
		parts.push(...modWords);
	}

	return sanitizeName(parts.join(" "));
}

function sanitizeName(raw: string): string {
	return raw
		.toLowerCase()
		.replace(/[^\w\s-]/g, "")
		.trim()
		.replace(/\s+/g, "-")
		.replace(/-+/g, "-")
		.slice(0, 40);
}

// ─── Tag Generation ────────────────────────────────────────────────────────

function generateTags(analysis: TaskAnalysis, source: SourceResult): string[] {
	const tags = new Set<string>();

	// Domain
	if (analysis.domain !== "unknown") {
		tags.add(analysis.domain);
	}

	// Verbs from intents
	for (const intent of analysis.intents) {
		tags.add(intent.verb);
	}

	// Source tier
	tags.add(source.tier);

	// Commands
	for (const cmd of source.commands) {
		// Extract base command name
		const base = cmd.split(/\s+/)[0];
		if (base) tags.add(base);
	}

	// Implementation type
	tags.add(source.implementation.type);

	// Auto-generated marker
	tags.add("auto-generated");
	tags.add("shiksha");

	return [...tags];
}

// ─── Capability Generation ─────────────────────────────────────────────────

function generateCapabilities(analysis: TaskAnalysis): SkillCapability[] {
	return analysis.intents.map((intent) => ({
		verb: intent.verb,
		object: intent.object,
		description: `${intent.verb} ${intent.object}${intent.modifier ? ` ${intent.modifier}` : ""}`,
	}));
}

// ─── Description Generation ────────────────────────────────────────────────

function generateDescription(analysis: TaskAnalysis, source: SourceResult): string {
	// Cloud recipe tier — special description
	if (source.tier === "cloud-recipe" && source.cloudResult) {
		const recipe = source.cloudResult.recipe ?? source.cloudResult.alternatives[0]?.recipe;
		if (recipe) {
			return `Cloud recipe for ${recipe.name} (${recipe.provider}). Auto-generated by Shiksha/Megha.`;
		}
		return `Cloud task: ${analysis.query}. Auto-generated by Shiksha/Megha.`;
	}

	const impl = source.implementation;

	switch (impl.type) {
		case "shell":
			return `Executes \`${source.commands[0] ?? impl.script}\` to ${analysis.intents.map((i) => `${i.verb} ${i.object}`).join(", ")}. Auto-generated by Shiksha.`;
		case "tool-chain":
			return `Uses ${impl.tools.join(" + ")} to ${analysis.intents.map((i) => `${i.verb} ${i.object}`).join(", ")}. Auto-generated by Shiksha.`;
		case "typescript":
			return `TypeScript implementation to ${analysis.intents.map((i) => `${i.verb} ${i.object}`).join(", ")}. Auto-generated by Shiksha.`;
		case "llm-chain":
			return `LLM-assisted pipeline to ${analysis.intents.map((i) => `${i.verb} ${i.object}`).join(", ")}. Auto-generated by Shiksha.`;
	}
}

// ─── Skill.md Content Generation ───────────────────────────────────────────

function generateSkillContent(manifest: SkillManifest, impl: SourceImplementation): string {
	// Use the standard writer for the manifest part
	const baseContent = writeSkillMarkdown(manifest);

	// Append implementation section
	const implSection = generateImplementationSection(impl);

	return `${baseContent}\n${implSection}`;
}

function generateImplementationSection(impl: SourceImplementation): string {
	const lines: string[] = ["## Implementation", ""];

	switch (impl.type) {
		case "shell":
			lines.push("```bash");
			lines.push(impl.script);
			lines.push("```");
			break;
		case "tool-chain":
			lines.push("### Tool Chain");
			lines.push("");
			for (let i = 0; i < impl.steps.length; i++) {
				lines.push(`${i + 1}. ${impl.steps[i]}`);
			}
			break;
		case "typescript":
			lines.push("```typescript");
			lines.push(impl.code);
			lines.push("```");
			break;
		case "llm-chain":
			lines.push("### System Prompt");
			lines.push("");
			lines.push(impl.systemPrompt);
			lines.push("");
			lines.push("### Steps");
			lines.push("");
			for (let i = 0; i < impl.steps.length; i++) {
				lines.push(`${i + 1}. ${impl.steps[i]}`);
			}
			break;
	}

	lines.push("");
	return lines.join("\n");
}

// ─── Main Entry Point ──────────────────────────────────────────────────────

/**
 * Build a complete skill from task analysis and source result.
 *
 * Generates:
 * - SkillManifest with computed trait vector
 * - Skill.md content for persistence
 * - Typed implementation reference
 *
 * @param analysis - Task analysis from VimarshAnalyzer.
 * @param source - Source result from PraptyaSourcer.
 * @returns Complete generated skill.
 */
export function buildSkill(
	analysis: TaskAnalysis,
	source: SourceResult,
): GeneratedSkill {
	const name = generateSkillName(analysis);
	const tags = generateTags(analysis, source);
	const capabilities = generateCapabilities(analysis);
	const description = generateDescription(analysis, source);

	const manifest: SkillManifest = {
		name,
		version: "1.0.0",
		description,
		author: "shiksha",
		capabilities,
		tags,
		source: { type: "generated", generator: "shiksha" },
		examples: [{
			description: analysis.query,
			input: { query: analysis.query },
			output: `Executes via ${source.tier}`,
		}],
		updatedAt: new Date().toISOString(),
	};

	// Compute trait vector
	manifest.traitVector = Array.from(computeTraitVector(manifest));

	// Generate skill.md content
	const content = generateSkillContent(manifest, source.implementation);

	return {
		manifest,
		content,
		implementation: source.implementation,
		sourceResult: source,
		taskAnalysis: analysis,
	};
}

// ─── Exports for testing ───────────────────────────────────────────────────

export {
	generateSkillName,
	generateTags,
	generateCapabilities,
	generateDescription,
	generateSkillContent,
	sanitizeName,
};
