import { describe, it, expect } from "vitest";
import {
	buildSkill,
	generateSkillName,
	generateTags,
	generateCapabilities,
	generateDescription,
	generateSkillContent,
	sanitizeName,
} from "../../src/shiksha/nirmana.js";
import type {
	TaskAnalysis,
	SourceResult,
	SourceImplementation,
} from "../../src/shiksha/types.js";
import type { SkillManifest } from "../../src/types.js";

// ─── Fixtures ───────────────────────────────────────────────────────────────

function makeTaskAnalysis(overrides: Partial<TaskAnalysis> = {}): TaskAnalysis {
	return {
		query: "check devices on network",
		intents: [
			{ verb: "check", object: "devices", modifier: "on network" },
		],
		strategy: "shell-command",
		complexity: "simple",
		candidateUtilities: [
			{
				command: "arp",
				template: "arp -a",
				confidence: 0.9,
				requiresPrivilege: false,
				requiresNetwork: true,
				domain: "network",
			},
		],
		domain: "network",
		confidence: 0.85,
		...overrides,
	};
}

function makeSourceResult(overrides: Partial<SourceResult> = {}): SourceResult {
	return {
		tier: "system-utility",
		implementation: { type: "shell", script: "arp -a" },
		commands: ["arp -a"],
		toolChain: [],
		...overrides,
	};
}

function makeToolChainSource(): SourceResult {
	return {
		tier: "builtin-tool",
		implementation: {
			type: "tool-chain",
			tools: ["grep", "find"],
			steps: ["Find matching files", "Grep for pattern"],
		},
		commands: [],
		toolChain: ["grep", "find"],
	};
}

function makeManifest(overrides: Partial<SkillManifest> = {}): SkillManifest {
	return {
		name: "check-devices-network",
		version: "1.0.0",
		description: "Executes `arp -a` to check devices. Auto-generated by Shiksha.",
		author: "shiksha",
		capabilities: [
			{ verb: "check", object: "devices", description: "check devices on network" },
		],
		tags: ["network", "check", "system-utility", "arp", "shell", "auto-generated", "shiksha"],
		source: { type: "generated", generator: "shiksha" },
		updatedAt: "2026-01-01T00:00:00Z",
		...overrides,
	};
}

// ─── generateSkillName ──────────────────────────────────────────────────────

describe("generateSkillName", () => {
	it("builds name from first intent verb + object", () => {
		const analysis = makeTaskAnalysis();
		const name = generateSkillName(analysis);
		expect(name).toBe("check-devices-network");
	});

	it("includes modifier words longer than 2 chars", () => {
		const analysis = makeTaskAnalysis({
			intents: [
				{ verb: "find", object: "files", modifier: "in the directory recursively" },
			],
		});
		const name = generateSkillName(analysis);
		expect(name).toContain("find");
		expect(name).toContain("files");
		expect(name).toContain("directory");
		expect(name).toContain("recursively");
		// "the" (stopword) should be filtered out
		expect(name).not.toContain("-the-");
	});

	it("sanitizes the result to kebab-case", () => {
		const analysis = makeTaskAnalysis({
			intents: [{ verb: "Check", object: "Disk Space" }],
		});
		const name = generateSkillName(analysis);
		expect(name).toBe("check-disk-space");
	});

	it("truncates name to max 40 characters", () => {
		const analysis = makeTaskAnalysis({
			intents: [
				{
					verb: "investigate",
					object: "abnormalities",
					modifier: "across the entire distributed infrastructure system",
				},
			],
		});
		const name = generateSkillName(analysis);
		expect(name.length).toBeLessThanOrEqual(40);
	});
});

// ─── sanitizeName ───────────────────────────────────────────────────────────

describe("sanitizeName", () => {
	it("removes special characters", () => {
		expect(sanitizeName("hello@world!")).toBe("helloworld");
	});

	it("converts spaces to hyphens", () => {
		expect(sanitizeName("check disk space")).toBe("check-disk-space");
	});

	it("collapses double hyphens", () => {
		expect(sanitizeName("check--disk--space")).toBe("check-disk-space");
	});

	it("lowercases everything", () => {
		expect(sanitizeName("CHECK DISK")).toBe("check-disk");
	});

	it("trims whitespace before processing", () => {
		expect(sanitizeName("  hello world  ")).toBe("hello-world");
	});

	it("caps at 40 characters", () => {
		const long = "a".repeat(50);
		expect(sanitizeName(long).length).toBe(40);
	});
});

// ─── generateTags ───────────────────────────────────────────────────────────

describe("generateTags", () => {
	it("includes domain tag", () => {
		const tags = generateTags(makeTaskAnalysis(), makeSourceResult());
		expect(tags).toContain("network");
	});

	it("includes verb from intents", () => {
		const tags = generateTags(makeTaskAnalysis(), makeSourceResult());
		expect(tags).toContain("check");
	});

	it("includes source tier", () => {
		const tags = generateTags(makeTaskAnalysis(), makeSourceResult());
		expect(tags).toContain("system-utility");
	});

	it("includes base command from commands array", () => {
		const tags = generateTags(makeTaskAnalysis(), makeSourceResult());
		expect(tags).toContain("arp");
	});

	it("always includes auto-generated and shiksha markers", () => {
		const tags = generateTags(makeTaskAnalysis(), makeSourceResult());
		expect(tags).toContain("auto-generated");
		expect(tags).toContain("shiksha");
	});

	it("includes implementation type", () => {
		const tags = generateTags(makeTaskAnalysis(), makeSourceResult());
		expect(tags).toContain("shell");
	});

	it("omits 'unknown' domain", () => {
		const analysis = makeTaskAnalysis({ domain: "unknown" });
		const tags = generateTags(analysis, makeSourceResult());
		expect(tags).not.toContain("unknown");
	});
});

// ─── generateCapabilities ───────────────────────────────────────────────────

describe("generateCapabilities", () => {
	it("maps intents to capabilities", () => {
		const caps = generateCapabilities(makeTaskAnalysis());
		expect(caps).toHaveLength(1);
		expect(caps[0].verb).toBe("check");
		expect(caps[0].object).toBe("devices");
	});

	it("includes modifier in description when present", () => {
		const caps = generateCapabilities(makeTaskAnalysis());
		expect(caps[0].description).toBe("check devices on network");
	});

	it("handles multiple intents", () => {
		const analysis = makeTaskAnalysis({
			intents: [
				{ verb: "find", object: "files" },
				{ verb: "count", object: "lines" },
			],
		});
		const caps = generateCapabilities(analysis);
		expect(caps).toHaveLength(2);
		expect(caps[1].verb).toBe("count");
		expect(caps[1].object).toBe("lines");
	});

	it("omits modifier from description when absent", () => {
		const analysis = makeTaskAnalysis({
			intents: [{ verb: "list", object: "files" }],
		});
		const caps = generateCapabilities(analysis);
		expect(caps[0].description).toBe("list files");
	});
});

// ─── generateDescription ────────────────────────────────────────────────────

describe("generateDescription", () => {
	it("shell: includes command and 'Auto-generated by Shiksha'", () => {
		const desc = generateDescription(makeTaskAnalysis(), makeSourceResult());
		expect(desc).toContain("arp -a");
		expect(desc).toContain("Auto-generated by Shiksha");
	});

	it("tool-chain: lists tools joined with +", () => {
		const desc = generateDescription(makeTaskAnalysis(), makeToolChainSource());
		expect(desc).toContain("grep + find");
		expect(desc).toContain("Auto-generated by Shiksha");
	});

	it("typescript: mentions TypeScript implementation", () => {
		const source = makeSourceResult({
			implementation: { type: "typescript", code: "console.log(1)", entrypoint: "main" },
		});
		const desc = generateDescription(makeTaskAnalysis(), source);
		expect(desc).toContain("TypeScript implementation");
	});

	it("llm-chain: mentions LLM-assisted pipeline", () => {
		const source = makeSourceResult({
			implementation: {
				type: "llm-chain",
				systemPrompt: "You are helpful",
				steps: ["Parse input", "Generate output"],
			},
		});
		const desc = generateDescription(makeTaskAnalysis(), source);
		expect(desc).toContain("LLM-assisted pipeline");
	});
});

// ─── generateSkillContent ───────────────────────────────────────────────────

describe("generateSkillContent", () => {
	it("shell: includes Implementation section with bash code block", () => {
		const impl: SourceImplementation = { type: "shell", script: "arp -a" };
		const content = generateSkillContent(makeManifest(), impl);
		expect(content).toContain("## Implementation");
		expect(content).toContain("```bash");
		expect(content).toContain("arp -a");
		expect(content).toContain("```");
	});

	it("tool-chain: includes numbered steps", () => {
		const impl: SourceImplementation = {
			type: "tool-chain",
			tools: ["grep", "find"],
			steps: ["Find matching files", "Grep for pattern"],
		};
		const content = generateSkillContent(makeManifest(), impl);
		expect(content).toContain("### Tool Chain");
		expect(content).toContain("1. Find matching files");
		expect(content).toContain("2. Grep for pattern");
	});

	it("includes frontmatter from manifest", () => {
		const impl: SourceImplementation = { type: "shell", script: "ls" };
		const content = generateSkillContent(makeManifest(), impl);
		expect(content).toContain("---");
		expect(content).toContain("name: check-devices-network");
	});
});

// ─── buildSkill (full pipeline) ─────────────────────────────────────────────

describe("buildSkill", () => {
	it("returns a GeneratedSkill with all fields populated", () => {
		const analysis = makeTaskAnalysis();
		const source = makeSourceResult();
		const result = buildSkill(analysis, source);

		expect(result.manifest).toBeDefined();
		expect(result.content).toBeDefined();
		expect(result.implementation).toBe(source.implementation);
		expect(result.sourceResult).toBe(source);
		expect(result.taskAnalysis).toBe(analysis);
	});

	it("manifest has computed traitVector", () => {
		const result = buildSkill(makeTaskAnalysis(), makeSourceResult());
		expect(result.manifest.traitVector).toBeDefined();
		expect(Array.isArray(result.manifest.traitVector)).toBe(true);
		expect(result.manifest.traitVector!.length).toBeGreaterThan(0);
	});

	it("manifest has version 1.0.0 and author shiksha", () => {
		const result = buildSkill(makeTaskAnalysis(), makeSourceResult());
		expect(result.manifest.version).toBe("1.0.0");
		expect(result.manifest.author).toBe("shiksha");
	});

	it("manifest source is generated by shiksha", () => {
		const result = buildSkill(makeTaskAnalysis(), makeSourceResult());
		expect(result.manifest.source).toEqual({ type: "generated", generator: "shiksha" });
	});

	it("content string is non-empty and includes implementation", () => {
		const result = buildSkill(makeTaskAnalysis(), makeSourceResult());
		expect(result.content.length).toBeGreaterThan(0);
		expect(result.content).toContain("## Implementation");
	});

	it("manifest has examples derived from query", () => {
		const result = buildSkill(makeTaskAnalysis(), makeSourceResult());
		expect(result.manifest.examples).toBeDefined();
		expect(result.manifest.examples![0].description).toBe("check devices on network");
	});
});

// ─── Edge Cases ─────────────────────────────────────────────────────────────

describe("edge cases", () => {
	it("no intents: falls back to sanitized query for name", () => {
		const analysis = makeTaskAnalysis({ intents: [] });
		const name = generateSkillName(analysis);
		expect(name).toBe("check-devices-on-network");
	});

	it("empty modifier: no extra words appended", () => {
		const analysis = makeTaskAnalysis({
			intents: [{ verb: "list", object: "files", modifier: "" }],
		});
		const name = generateSkillName(analysis);
		expect(name).toBe("list-files");
	});

	it("modifier with only stopwords: no extra words appended", () => {
		const analysis = makeTaskAnalysis({
			intents: [{ verb: "list", object: "files", modifier: "my the an" }],
		});
		const name = generateSkillName(analysis);
		expect(name).toBe("list-files");
	});

	it("generateCapabilities with zero intents returns empty array", () => {
		const analysis = makeTaskAnalysis({ intents: [] });
		const caps = generateCapabilities(analysis);
		expect(caps).toEqual([]);
	});
});
